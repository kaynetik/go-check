
<h2 align="center">
  <img align="center" src="docs/resources/gopher-checking.svg" alt="fast-check logo" width=200px /> 
  Checking...
</h2>

## Intro

**Go Check** is a property based testing (also known as generative testing) framework for Go programming language. In property based testing, you state facts about your code that for given precondition should always be true. Framework then tests these facts with random inputs to verify the statements. Unlike fuzzy testing if the statement doesn't hold, framework tries to find the input with smallest complexity for which it doesn't. 
## Motivation

Writting tests gives a confidence that written code works, and rewritten code doesn't break. One of the standard ways of writting tests is by defining test cases, a set of inputs for which it needs to be ensured that code under test works.

With property based testing paradigm of writting tests is shifted. Test cases are generated by the framework and writting tests comes down to defining properties that should always hold.

Go standard library does come with it's own module [quick](https://pkg.go.dev/testing/quick) for writting these types of tests. Sadly the package is frozen and is missing several important features like shrinking, and constraints for generated data. Without it, it is just another package for fuzzy testing.

## Installation
Installation is done as any other go package:
```
go get github.com/steffnova/go-check
```
## Quick Start

Go Check is integrated with **testing** package. Here is an example of commutativity property for integer addition operation:

```go
import (
    "fmt"
    "testing"

    "github.com/steffnova/go-check"
    "github.com/steffnova/go-check/generator"
)

func addInt(x, y) int {
    return x+y
}

func TestCommutativity(t *testing.T) {
    // Predicate is a function that will be used for defining a property. Predicate
    // can have variable number of inputs, but must have only one output of type error
    predicate := func(x, y int) error {
        // Test commutativity for integers
        if addInt(x, y) != addInt(y, x) {
            return fmt.Errorf("commutativity failed")
        }
        return nil
    }

    // Property requires a predicate function and generators. 
    // Number of generators must match number of inputs predicate has.
    // Generator's type with index i must match predicate's input with index i.
    property := check.Property(predicate,
        generator.Int(), 
        generator.Int(),
    )

    // Check test the property by generating random values generated by 
    // property's generators. 
    check.Check(t, property)
}
```

