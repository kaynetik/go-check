package generator

import (
	"fmt"
	"reflect"

	"github.com/steffnova/go-check/arbitrary"
	"github.com/steffnova/go-check/constraints"
	"github.com/steffnova/go-check/shrinker"
)

type Generate func() (arbitrary.Arbitrary, shrinker.Shrinker)

// Generator is Generator creator. It tries to create Generator for type specified
// by target parameter with provided Random instance as r parameter.
type Generator func(target reflect.Type, bias constraints.Bias, r Random) (Generate, error)

// Map maps receiver Arbitrary (arb) to a new Arbitrary using mapper. Mapper must be a
// function that has one input and one output. Mappers's input type must satisfy
// target's type. Mapper's output defines the Generator type created by mapped
// Arbitrary.
func (arb Generator) Map(mapper interface{}) Generator {
	return func(target reflect.Type, bias constraints.Bias, r Random) (Generate, error) {
		val := reflect.ValueOf(mapper)
		switch {
		case val.Kind() != reflect.Func:
			return nil, fmt.Errorf("mapper must be a function")
		case val.Type().NumOut() != 1:
			return nil, fmt.Errorf("mapper must have 1 output value")
		case val.Type().NumIn() != 1:
			return nil, fmt.Errorf("mapper must have 1 input value")
		case val.Type().Out(0).Kind() != target.Kind():
			return nil, fmt.Errorf("ARB mappers output parameter's kind: %s must match target's kind. Got: %s", val.Type().Out(0).Kind(), target.Kind())
		}

		generator, err := arb(val.Type().In(0), bias, r)
		if err != nil {
			return nil, fmt.Errorf("failed to create base generator. %s", err)
		}

		return func() (arbitrary.Arbitrary, shrinker.Shrinker) {
			arb, shrinker := generator()
			return arbitrary.Arbitrary{
				Value:      reflect.ValueOf(mapper).Call([]reflect.Value{arb.Value})[0],
				Precursors: []arbitrary.Arbitrary{arb},
			}, shrinker.Map(mapper)
		}, nil
	}
}

// Filter creates new Arbitrary from receiver Arbitrary (arb) using predicate. Predicate
// is a function that has one input and one output. Input paramter must satisfy target's
// type, while output parameter must be bool. Generator returned by new Arbitrary will
// generate values that satisfy predicate.
//
// NOTE: This can highly impact Generator's time to generate a value as it will try to
// generate target's values unitl predicate is satisfied.
func (arb Generator) Filter(predicate interface{}) Generator {
	return func(target reflect.Type, bias constraints.Bias, r Random) (Generate, error) {
		generate, err := arb(target, bias, r)
		switch val := reflect.ValueOf(predicate); {
		case err != nil:
			return nil, fmt.Errorf("failed to create base generator. %s", err)
		case val.Kind() != reflect.Func:
			return nil, fmt.Errorf("predicate must be a function")
		case val.Type().NumIn() != 1:
			return nil, fmt.Errorf("predicate must have one input value")
		case val.Type().NumOut() != 1:
			return nil, fmt.Errorf("predicate must have one output value")
		case val.Type().Out(0).Kind() != reflect.Bool:
			return nil, fmt.Errorf("predicate must have bool as a output value")
		}

		return func() (arbitrary.Arbitrary, shrinker.Shrinker) {
			for {
				arb, shrinker := generate()
				outputs := reflect.ValueOf(predicate).Call([]reflect.Value{arb.Value})
				if outputs[0].Bool() {
					return arb, shrinker.Filter(arb, predicate)
				}
			}
		}, nil
	}
}

// Bind binds the arb with Arbitrary returned from binder. Binder is a function
// that has one input value and it's type must match the type generated by arb,
// it has one output value which must be an Arbitrary. With Bind it is possible
// to use generated value of one generator as an input for another generator.
func (arb Generator) Bind(binder interface{}, retries uint) Generator {
	return func(target reflect.Type, bias constraints.Bias, r Random) (Generate, error) {
		binderVal := reflect.ValueOf(binder)
		switch t := reflect.TypeOf(binder); {
		case t.Kind() != reflect.Func:
			return nil, fmt.Errorf("binder must be a function")
		case t.NumIn() != 1:
			return nil, fmt.Errorf("binder must have one input value")
		case t.NumOut() != 1:
			return nil, fmt.Errorf("binder must have one output values")
		case t.Out(0) != reflect.TypeOf(Generator(nil)):
			return nil, fmt.Errorf("binder's output value must be generator.Arbitrary")
		}

		sourceGenerator, err := arb(binderVal.Type().In(0), bias, r)
		if err != nil {
			return nil, fmt.Errorf("failed to create base generator")
		}
		sourceVal, sourceShrinker := sourceGenerator()

		outputs := binderVal.Call([]reflect.Value{sourceVal.Value})
		boundGenerator, err := outputs[0].Interface().(Generator)(target, bias, r)
		if err != nil {
			return nil, fmt.Errorf("generator composition failed: %s", err)
		}

		return func() (arbitrary.Arbitrary, shrinker.Shrinker) {
			boundVal, boundShrinker := boundGenerator()

			binder := func(source arbitrary.Arbitrary) (arbitrary.Arbitrary, shrinker.Shrinker, error) {
				outputs := binderVal.Call([]reflect.Value{source.Value})
				generator, err := outputs[0].Interface().(Generator)(target, bias, r)
				if err != nil {
					return arbitrary.Arbitrary{}, nil, fmt.Errorf("generator binding failed: %s", err)
				}

				val, shrinker := generator()
				return val, shrinker, nil
			}

			boundVal.Precursors = []arbitrary.Arbitrary{sourceVal}

			return boundVal, sourceShrinker.
				Retry(retries, retries, sourceVal).
				Bind(binder, boundShrinker, boundShrinker)
		}, nil
	}
}

func InvalidGen(err error) Generator {
	return func(target reflect.Type, bias constraints.Bias, r Random) (Generate, error) {
		return nil, err
	}
}
